<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="deployment.yaml文件详解       123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s各类yaml文件">
<meta property="og:url" content="http://zhho.cn/2020/10/23/k8s%E5%90%84%E7%B1%BByaml%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Hao&#39;s blog">
<meta property="og:description" content="deployment.yaml文件详解       123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdn.net/20171208160333046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQTYzMjE4OTAwNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2020-10-23T07:44:34.000Z">
<meta property="article:modified_time" content="2020-10-23T08:32:39.993Z">
<meta property="article:author" content="Hao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20171208160333046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQTYzMjE4OTAwNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><title>k8s各类yaml文件 | Hao's blog</title><link ref="canonical" href="http://zhho.cn/2020/10/23/k8s%E5%90%84%E7%B1%BByaml%E6%96%87%E4%BB%B6/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hao's blog</div><div class="header-banner-info__subtitle">No pains ,no gains</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">k8s各类yaml文件</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-10-23</span></span></div></header><div class="post-body"><hr>

        <h3 id="deployment-yaml文件详解"   >
          <a href="#deployment-yaml文件详解" class="heading-link"><i class="fas fa-link"></i></a>deployment.yaml文件详解</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   #接口版本</span><br><span class="line">kind: Deployment                 #接口类型</span><br><span class="line">metadata:</span><br><span class="line">  name: cango-demo               #Deployment名称</span><br><span class="line">  namespace: cango-prd           #命名空间</span><br><span class="line">  labels:</span><br><span class="line">    app: cango-demo              #标签</span><br><span class="line">spec:           #specification of the resource content 指定该资源的内容</span><br><span class="line">  replicas: 3</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:  ##由于replicas为3,则整个升级,pod个数在2-4个之间</span><br><span class="line">      maxSurge: 1      #滚动升级时会先启动1个pod</span><br><span class="line">      maxUnavailable: 1 #滚动升级时允许的最大Unavailable的pod个数</span><br><span class="line">  template:         </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cango-demo  #模板名称必填</span><br><span class="line">    sepc: #定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:                                                                   </span><br><span class="line">        - name: cango-demo                                                           #镜像名称</span><br><span class="line">          image: swr.cn-east-2.myhuaweicloud.com&#x2F;cango-prd&#x2F;cango-demo:0.0.1-SNAPSHOT #镜像地址</span><br><span class="line">          command: [ &quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;cat &#x2F;etc&#x2F;config&#x2F;path&#x2F;to&#x2F;special-key&quot; ]    #启动命令</span><br><span class="line">          args:                                                                #启动参数</span><br><span class="line">            - &#39;-storage.local.retention&#x3D;$(STORAGE_RETENTION)&#39;</span><br><span class="line">            - &#39;-storage.local.memory-chunks&#x3D;$(STORAGE_MEMORY_CHUNKS)&#39;</span><br><span class="line">            - &#39;-config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml&#39;</span><br><span class="line">            - &#39;-alertmanager.url&#x3D;http:&#x2F;&#x2F;alertmanager:9093&#x2F;alertmanager&#39;</span><br><span class="line">            - &#39;-web.external-url&#x3D;$(EXTERNAL_URL)&#39;</span><br><span class="line">    #如果command和args均没有写，那么用Docker默认的配置。</span><br><span class="line">    #如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。</span><br><span class="line">    #如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。</span><br><span class="line">    #如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。</span><br><span class="line">          imagePullPolicy: IfNotPresent  #如果不存在则拉取</span><br><span class="line">          livenessProbe:       #表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；</span><br><span class="line">            httpGet:</span><br><span class="line">              path: &#x2F;health #如果没有心跳检测接口就为&#x2F;</span><br><span class="line">              port: 8080</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 60 ##启动后延时多久开始运行检测</span><br><span class="line">            timeoutSeconds: 5</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            failureThreshold: 5</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: &#x2F;health #如果没有心跳检测接口就为&#x2F;</span><br><span class="line">              port: 8080</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 30 ##启动后延时多久开始运行检测</span><br><span class="line">            timeoutSeconds: 5</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            failureThreshold: 5</span><br><span class="line">          resources:              ##CPU内存限制</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 2</span><br><span class="line">              memory: 2048Mi</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 2</span><br><span class="line">              memory: 2048Mi</span><br><span class="line">          env:                    ##通过环境变量的方式，直接传递pod&#x3D;自定义Linux OS环境变量</span><br><span class="line">            - name: LOCAL_KEY     #本地Key</span><br><span class="line">              value: value</span><br><span class="line">            - name: CONFIG_MAP_KEY  #局策略可使用configMap的配置Key，</span><br><span class="line">              valueFrom:</span><br><span class="line">                configMapKeyRef:</span><br><span class="line">                  name: special-config   #configmap中找到name为special-config</span><br><span class="line">                  key: special.type      #找到name为special-config里data下的key</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080 #对service暴露端口</span><br><span class="line">          volumeMounts:     #挂载volumes中定义的磁盘</span><br><span class="line">          - name: log-cache</span><br><span class="line">            mount: &#x2F;tmp&#x2F;log</span><br><span class="line">          - name: sdb       #普通用法，该卷跟随容器销毁，挂载一个目录</span><br><span class="line">            mountPath: &#x2F;data&#x2F;media    </span><br><span class="line">          - name: nfs-client-root    #直接挂载硬盘方法，如挂载下面的nfs目录到&#x2F;mnt&#x2F;nfs</span><br><span class="line">            mountPath: &#x2F;mnt&#x2F;nfs</span><br><span class="line">          - name: example-volume-config  #高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到&#x2F;etc&#x2F;config目录下的一个相对路径path&#x2F;to&#x2F;...下，如果存在同名文件，直接覆盖。</span><br><span class="line">            mountPath: &#x2F;etc&#x2F;config       </span><br><span class="line">          - name: rbd-pvc                #高级用法第2中，挂载PVC(PresistentVolumeClaim)</span><br><span class="line"> </span><br><span class="line">#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，</span><br><span class="line">  volumes:  # 定义磁盘给上面volumeMounts挂载</span><br><span class="line">  - name: log-cache</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">  - name: sdb  #挂载宿主机上面的目录</span><br><span class="line">    hostPath:</span><br><span class="line">      path: &#x2F;any&#x2F;path&#x2F;it&#x2F;will&#x2F;be&#x2F;replaced</span><br><span class="line">  - name: example-volume-config  # 供ConfigMap文件内容到指定路径使用</span><br><span class="line">    configMap:</span><br><span class="line">      name: example-volume-config  #ConfigMap中名称</span><br><span class="line">      items:</span><br><span class="line">      - key: log-script           #ConfigMap中的Key</span><br><span class="line">        path: path&#x2F;to&#x2F;log-script  #指定目录下的一个相对路径path&#x2F;to&#x2F;log-script</span><br><span class="line">      - key: backup-script        #ConfigMap中的Key</span><br><span class="line">        path: path&#x2F;to&#x2F;backup-script  #指定目录下的一个相对路径path&#x2F;to&#x2F;backup-script</span><br><span class="line">  - name: nfs-client-root         #供挂载NFS存储类型</span><br><span class="line">    nfs:</span><br><span class="line">      server: 10.42.0.55          #NFS服务器地址</span><br><span class="line">      path: &#x2F;opt&#x2F;public           #showmount -e 看一下路径</span><br><span class="line">  - name: rbd-pvc                 #挂载PVC磁盘</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: rbd-pvc1         #挂载已经申请的pvc磁盘</span><br></pre></td></tr></table></div></figure>

<a id="more"></a>


        <h3 id="Pod-yaml文件详解"   >
          <a href="#Pod-yaml文件详解" class="heading-link"><i class="fas fa-link"></i></a>Pod yaml文件详解</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"># yaml格式的pod定义文件完整内容：</span><br><span class="line">apiVersion: v1       #必选，版本号，例如v1</span><br><span class="line">kind: Pod       #必选，Pod</span><br><span class="line">metadata:       #必选，元数据</span><br><span class="line">  name: string       #必选，Pod名称</span><br><span class="line">  namespace: string    #必选，Pod所属的命名空间</span><br><span class="line">  labels:      #自定义标签</span><br><span class="line">    - name: string     #自定义标签名字</span><br><span class="line">  annotations:       #自定义注释列表</span><br><span class="line">    - name: string</span><br><span class="line">spec:         #必选，Pod中容器的详细定义</span><br><span class="line">  containers:      #必选，Pod中容器列表</span><br><span class="line">  - name: string     #必选，容器名称</span><br><span class="line">    image: string    #必选，容器的镜像名称</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span><br><span class="line">    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]     #容器的启动命令参数列表</span><br><span class="line">    workingDir: string     #容器的工作目录</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存清楚，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br><span class="line">    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span><br><span class="line">    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br></pre></td></tr></table></div></figure>


        <h3 id="Service-yaml文件详解"   >
          <a href="#Service-yaml文件详解" class="heading-link"><i class="fas fa-link"></i></a>Service yaml文件详解</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">matadata:                                #元数据</span><br><span class="line">  name: string                           #service的名称</span><br><span class="line">  namespace: string                      #命名空间  </span><br><span class="line">  labels:                                #自定义标签属性列表</span><br><span class="line">    - name: string</span><br><span class="line">  annotations:                           #自定义注解属性列表  </span><br><span class="line">    - name: string</span><br><span class="line">spec:                                    #详细描述</span><br><span class="line">  selector: []                           #label selector配置，将选择具有label标签的Pod作为管理 </span><br><span class="line">                                         #范围</span><br><span class="line">  type: string                           #service的类型，指定service的访问方式，默认为 </span><br><span class="line">                                         #clusterIp</span><br><span class="line">  clusterIP: string                      #虚拟服务地址      </span><br><span class="line">  sessionAffinity: string                #是否支持session</span><br><span class="line">  ports:                                 #service需要暴露的端口列表</span><br><span class="line">  - name: string                         #端口名称</span><br><span class="line">    protocol: string                     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    port: int                            #服务监听的端口号</span><br><span class="line">    targetPort: int                      #需要转发到后端Pod的端口号</span><br><span class="line">    nodePort: int                        #当type &#x3D; NodePort时，指定映射到物理机的端口号</span><br><span class="line">  status:                                #当spce.type&#x3D;LoadBalancer时，设置外部负载均衡器的地址</span><br><span class="line">    loadBalancer:                        #外部负载均衡器    </span><br><span class="line">      ingress:                           #外部负载均衡器 </span><br><span class="line">        ip: string                       #外部负载均衡器的Ip地址值</span><br><span class="line">        hostname: string                 #外部负载均衡器的主机名</span><br></pre></td></tr></table></div></figure>



<p><img   src="https://img-blog.csdn.net/20171208160333046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQTYzMjE4OTAwNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style=""  alt="è¿éåå¾çæè¿°"></p>
<p>目前kubernetes提供了两种负载分发策略：RoundRobin和SessionAffinity</p>
<p>RoundRobin：轮询模式，即轮询将请求转发到后端的各个Pod上</p>
<p>SessionAffinity：基于客户端IP地址进行会话保持的模式，第一次客户端访问后端某个Pod，之后的请求都转发到这个Pod上</p>
<p>默认是RoundRobin模式</p>
<p>在某些场景中，开发人员希望自己控制负载均衡的策略，不使用Service提供的默认负载，kubernetes通过Headless Service的概念来实现。不给Service设置ClusterIP（无入口IP地址）：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></div></figure>

<p> 有时候，一个容器应用提供多个端口服务：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    name: web</span><br><span class="line">  - port: 8005</span><br><span class="line">    targetPort: 8005</span><br><span class="line">    name: management</span><br><span class="line">  selector:</span><br><span class="line">    app: webapp</span><br></pre></td></tr></table></div></figure>

<p>为不同的应用分配各自的端口。</p>
<p>另一个例子是两个端口使用了不同的4层协议，即TCP或UDP</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io&#x2F;cluster-service: &quot;true&quot;</span><br><span class="line">    kubernetes.io&#x2F;name: &quot;KubeDNS&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">  clusterIP: 169.169.0.100</span><br><span class="line">  ports:</span><br><span class="line">  - name: dns</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: UDP</span><br><span class="line">  - name: dns-tcp</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: TCP</span><br></pre></td></tr></table></div></figure>

<p>集群外部访问Pod或Service<br>为了让外部客户端可以访问这些服务，可以将Pod或者Service的端口号映射到宿主主机，使得客户端应用能够通过物理机访问容器应用。</p>
<p>将容器应用的端口号映射到物理机<br>通过设置容器级别的hostPort，将容器应用的端口号映射到物理机上：<br>pod-hostport.yaml：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp</span><br><span class="line">  labels:</span><br><span class="line">    app: webapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: webapp</span><br><span class="line">    image: tomcat</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      hostPort:8081</span><br></pre></td></tr></table></div></figure>

<p>创建这个Pod：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f pod-hostnetwork.yaml</span><br></pre></td></tr></table></div></figure>

<p>通过物理机的IP地址和8080端口访问Pod的容器服务：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.0.11.151:8080</span><br></pre></td></tr></table></div></figure>

<p><strong>将Service的端口号映射到物理机</strong></p>
<p>通过设置nodePort映射到物理机，同时设置Service的类型为NodePort：</p>
<p>webapp-svc-nodeport.yaml：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    nodePort: 8081</span><br><span class="line">  selector:</span><br><span class="line">    app: webapp</span><br></pre></td></tr></table></div></figure>

<p>创建这个Service：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f webapp-svc-nodeport.yaml</span><br></pre></td></tr></table></div></figure>

<p>通过物理机的IP和端口访问：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.0.11.151:8081</span><br></pre></td></tr></table></div></figure>


        <h3 id="ingress-yaml详解"   >
          <a href="#ingress-yaml详解" class="heading-link"><i class="fas fa-link"></i></a>ingress.yaml详解</h3>
      <p>通常情况下，service和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。从概念上讲，可能像下面这样：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internet</span><br><span class="line">      |</span><br><span class="line">------------</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></div></figure>

<p>Ingress是授权入站连接到达集群服务的规则集合。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></div></figure>

<p>你可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API server的方式来请求ingress。 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers" >Ingress controller</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>负责实现Ingress，通常使用负载平衡器，它还可以配置边界路由和其他前端，这有助于以HA方式处理流量。</p>
<p><strong>Ingress Resource</strong></p>
<p>最简化的Ingress配置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test-ingress</span><br><span class="line">spec:                                # Ingress spec 中包含配置一个loadbalancer或proxy server</span><br><span class="line">  rules:                             # 的所有信息。最重要的是，它包含了一个匹配所有入站请求的规</span><br><span class="line">  - http:                            # 则列表。目前ingress只支持http规则。</span><br><span class="line">      paths:</span><br><span class="line">      - path: &#x2F;testpath              # 每条http规则包含以下信息：一个host配置项（比如 </span><br><span class="line">                                     # for.bar.com，在这个例子中默认是*），path列表（比 </span><br><span class="line">                                     # 如：&#x2F;testpath），每个path都关联一个backend(比如 </span><br><span class="line">                                     # test:80)。在loadbalancer将流量转发到backend之前，所有的 </span><br><span class="line">                                     # 入站请求都要先匹配host和path。</span><br><span class="line">       backend:                        </span><br><span class="line">          serviceName: test          # backend是一个service:port的组合。Ingress的流量被转发到                        </span><br><span class="line">          servicePort: 80            #  它所匹配的backend</span><br></pre></td></tr></table></div></figure>

<p><strong>Ingress类型</strong></p>
<p>Kubernetes中已经存在一些概念可以暴露单个service，但是你仍然可以通过Ingress来实现，通过指定一个没有rule的默认backend的方式。</p>
<p>ingress.yaml定义文件：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test-ingress</span><br><span class="line">spec:</span><br><span class="line">  backend:</span><br><span class="line">    serviceName: testsvc</span><br><span class="line">    servicePort: 80</span><br></pre></td></tr></table></div></figure>

<p>使用<code>kubectl create -f</code>命令创建，然后查看ingress：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ing</span><br><span class="line">NAME                RULE          BACKEND        ADDRESS</span><br><span class="line">test-ingress        -             testsvc:80     107.178.254.228</span><br></pre></td></tr></table></div></figure>

<p><code>107.178.254.228</code>就是Ingress controller为了实现Ingress而分配的IP地址。<code>RULE</code>列表示所有发送给该IP的流量都被转发到了<code>BACKEND</code>所列的Kubernetes service上。</p>
<p><strong>简单展开</strong></p>
<p>如前面描述的那样，kubernete pod中的IP只在集群网络内部可见，我们需要在边界设置一个东西，让它能够接收ingress的流量并将它们转发到正确的端点上。这个东西一般是高可用的loadbalancer。使用Ingress能够允许你将loadbalancer的个数降低到最少，例如，假如你想要创建这样的一个设置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com -&gt; 178.91.123.132 -&gt; &#x2F; foo    s1:80</span><br><span class="line">                                 &#x2F; bar    s2:80</span><br></pre></td></tr></table></div></figure>

<p>你需要一个这样的ingress：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: foo.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: &#x2F;foo</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: s1</span><br><span class="line">          servicePort: 80</span><br><span class="line">      - path: &#x2F;bar</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: s2</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></div></figure>

<p>使用<code>kubectl create -f</code>创建完ingress后：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ing</span><br><span class="line">NAME      RULE          BACKEND   ADDRESS</span><br><span class="line">test      -</span><br><span class="line">          foo.bar.com</span><br><span class="line">          &#x2F;foo          s1:80</span><br><span class="line">          &#x2F;bar          s2:80</span><br></pre></td></tr></table></div></figure>

<p>只要服务（s1，s2）存在，Ingress controller就会将提供一个满足该Ingress的特定loadbalancer实现。 这一步完成后，您将在Ingress的最后一列看到loadbalancer的地址。</p>
<p><strong>基于名称的虚拟主机</strong></p>
<p>Name-based的虚拟主机在同一个IP地址下拥有多个主机名。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com --|                 |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132  |</span><br><span class="line">bar.foo.com --|                 |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></div></figure>

<p>下面这个ingress说明基于<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230#section-5.4" >Host header</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的后端loadbalancer的路由请求：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: foo.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: s1</span><br><span class="line">          servicePort: 80</span><br><span class="line">  - host: bar.foo.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: s2</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></div></figure>

<p><strong>默认backend</strong>：一个没有rule的ingress，如前面章节中所示，所有流量都将发送到一个默认backend。你可以用该技巧通知loadbalancer如何找到你网站的404页面，通过制定一些列rule和一个默认backend的方式。如果请求header中的host不能跟ingress中的host匹配，并且/或请求的URL不能与任何一个path匹配，则流量将路由到你的默认backend。</p>
<p><strong>转自 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/1885.html" >https://www.kubernetes.org.cn/1885.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://zhho.cn">Hao Zhang</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://zhho.cn/2020/10/23/k8s%E5%90%84%E7%B1%BByaml%E6%96%87%E4%BB%B6/">http://zhho.cn/2020/10/23/k8s%E5%90%84%E7%B1%BByaml%E6%96%87%E4%BB%B6/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/10/25/etcd%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">etcd集群部署</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/10/21/buff-cache-%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"><span class="paginator-prev__text">buff/cache 了解一下</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#deployment-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">
          deployment.yaml文件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">
          Pod yaml文件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">
          Service yaml文件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ingress-yaml%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">
          ingress.yaml详解</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Meteor across</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">31</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Hao Zhang</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.1.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>